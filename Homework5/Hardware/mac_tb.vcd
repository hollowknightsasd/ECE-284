$date
	Tue Oct 25 10:36:27 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module mac_tb $end
$var wire 16 ! out [15:0] $end
$var parameter 32 " bw $end
$var parameter 32 # psum_bw $end
$var reg 16 $ a [15:0] $end
$var reg 16 % b [15:0] $end
$var reg 16 & c [15:0] $end
$var reg 1 ' clk $end
$var reg 16 ( expected_out [15:0] $end
$var reg 16 ) expected_out1 [15:0] $end
$var reg 16 * expected_out2 [15:0] $end
$var reg 16 + expected_out3 [15:0] $end
$var reg 16 , expected_out4 [15:0] $end
$var integer 32 - i [31:0] $end
$var integer 32 . w_dec [31:0] $end
$var integer 32 / w_file [31:0] $end
$var integer 32 0 w_scan_file [31:0] $end
$var integer 32 1 x_dec [31:0] $end
$var integer 32 2 x_file [31:0] $end
$var integer 32 3 x_scan_file [31:0] $end
$scope function mac_predicted $end
$var reg 4 4 a [3:0] $end
$var reg 5 5 a_q [4:0] $end
$var reg 4 6 b [3:0] $end
$var reg 16 7 c [15:0] $end
$var reg 8 8 multi [7:0] $end
$upscope $end
$scope function w_bin $end
$var integer 32 9 weight [31:0] $end
$upscope $end
$scope function x_bin $end
$var integer 32 : x [31:0] $end
$upscope $end
$scope module mac_wrapper_instance $end
$var wire 16 ; a [15:0] $end
$var wire 16 < b [15:0] $end
$var wire 16 = c [15:0] $end
$var wire 1 ' clk $end
$var wire 16 > out [15:0] $end
$var parameter 32 ? bw $end
$var parameter 32 @ psum_bw $end
$var reg 16 A a_q [15:0] $end
$var reg 16 B b_q [15:0] $end
$var reg 16 C c_q [15:0] $end
$scope module mac_instance $end
$var wire 16 D a [15:0] $end
$var wire 16 E b [15:0] $end
$var wire 16 F c [15:0] $end
$var wire 8 G product4 [7:0] $end
$var wire 8 H product3 [7:0] $end
$var wire 8 I product2 [7:0] $end
$var wire 8 J product1 [7:0] $end
$var wire 16 K out [15:0] $end
$var wire 10 L add2 [9:0] $end
$var wire 10 M add1 [9:0] $end
$var wire 5 N a4 [4:0] $end
$var wire 5 O a3 [4:0] $end
$var wire 5 P a2 [4:0] $end
$var wire 5 Q a1 [4:0] $end
$var parameter 32 R bw $end
$var parameter 32 S psum_bw $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b10000 S
b100 R
b10000 @
b100 ?
b10000 #
b100 "
$end
#0
$dumpvars
b0xxxx Q
b0xxxx P
b0xxxx O
b0xxxx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
b10000000000000000000000000000100 2
bx 1
bx 0
b10000000000000000000000000000011 /
bx .
bx -
b0 ,
b0 +
b0 *
b0 )
b0 (
0'
bx &
bx %
bx $
bx !
$end
#2
1'
#3
b1 3
b1010 1
b1 0
b100 .
b0 -
0'
#4
1'
#5
b1 -
b1111111111010000 (
b1111111111110100 ,
b111 +
b1111111111001111 *
b110 )
b11110100 8
b11 5
b11 4
b1100 6
b0 7
b0 &
b0 =
b1100011110010001 %
b1100011110010001 <
b0 9
b11000101110110 $
b11000101110110 ;
b1 :
0'
#6
b1111111111010000 !
b1111111111010000 >
b1111111111010000 K
b1111010101 M
b110 J
b110 Q
b11001111 I
b111 P
b1111111011 L
b111 H
b1 O
b11110100 G
b11 N
b0 C
b0 F
b11000101110110 A
b11000101110110 D
b1100011110010001 B
b1100011110010001 E
1'
#7
b10 -
b1111111110011110 (
b10100 ,
b1111111111000100 +
b1111111111111100 *
b1111111111111010 )
b10100 8
b100 5
b100 4
b101 6
b1111111111010000 &
b1111111111010000 =
b101110011101101 %
b101110011101101 <
b1 9
b100111100100010 $
b100111100100010 ;
b0 :
0'
#8
b10 Q
b10 P
b1111 O
b100 N
b11111010 J
b1111110110 M
b11111100 I
b11000100 H
b1111011000 L
b10100 G
b1111111110011110 !
b1111111110011110 >
b1111111110011110 K
b1111111111010000 C
b1111111111010000 F
b100111100100010 A
b100111100100010 D
b101110011101101 B
b101110011101101 E
1'
#9
b11 -
b1111111110000110 (
b1111111111111100 ,
b0 +
b10000 *
b1111111111011100 )
b11111100 8
b10 5
b10 4
b1110 6
b1111111110011110 &
b1111111110011110 =
b1110001001001010 %
b1110001001001010 <
b0 9
b10000001000110 $
b10000001000110 ;
b0 :
0'
#10
b110 Q
b100 P
b0 O
b10 N
b11011100 J
b1111101100 M
b10000 I
b0 H
b1111111100 L
b11111100 G
b1111111110000110 !
b1111111110000110 >
b1111111110000110 K
b1111111110011110 C
b1111111110011110 F
b10000001000110 A
b10000001000110 D
b1110001001001010 B
b1110001001001010 E
1'
#11
b100 -
b1111111101011001 (
b1111111111110101 ,
b110 +
b1111111111011000 *
b0 )
b11110101 8
b1011 5
b1011 4
b1111 6
b1111111110000110 &
b1111111110000110 =
b1111001111000000 %
b1111001111000000 <
b1 9
b1011001010100001 $
b1011001010100001 ;
b1 :
0'
#12
b1 Q
b1010 P
b110 H
b10 O
b1011 N
b0 J
b1111011000 M
b11011000 I
b1111111011 L
b11110101 G
b1111111101011001 !
b1111111101011001 >
b1111111101011001 K
b1111111110000110 C
b1111111110000110 F
b1011001010100001 A
b1011001010100001 D
b1111001111000000 B
b1111001111000000 E
1'
#13
b101 -
b1111111101111111 (
b101000 ,
b1111111111101000 +
b11110 *
b1111111111111000 )
b101000 8
b1010 5
b1010 4
b100 6
b1111111101011001 &
b1111111101011001 =
b100101001011100 %
b100101001011100 <
b0 9
b1010010001100010 $
b1010010001100010 ;
b0 :
0'
#14
b10 Q
b110 P
b100 O
b1010 N
b11111000 J
b10110 M
b11110 I
b11101000 H
b10000 L
b101000 G
b1111111101111111 !
b1111111101111111 >
b1111111101111111 K
b1111111101011001 C
b1111111101011001 F
b1010010001100010 A
b1010010001100010 D
b100101001011100 B
b100101001011100 E
1'
#15
0'
#25
